# 迈向Angular2：基于TypeScript的高性能SPA框架

## 总结

	写的很好，分析了angularJS的优缺点，以及angular2的关系，可深入细读


## 01

### Web Component

### WebWorker

js运行在单线程里面并以事件循环为主，事件调度的策略是：

	把各种事件都push到一个队列里面，然后再按照事件到达的顺序依次处理。
	然而，当其中某个预定的事件需要占用大量运算时间的时候，这种调度策略就很差。

WebWorker允许在另一个线程里面执行计算密集型任务，从而解放主线程，让它可以处理用户输入并渲染用户界面。

为什么angularjs不引入webworker？

	主要是因为框架和DOM操作紧耦合。在监视器回调函数内部，angularjs经常直接操作DOM，从而无法把监视器移动到WebWorker中去，因为WebWorker是在独立的上下文中被调用的，无法直接访问DOM。
	结论是：在主线程之外的独立线程里面监测改动很难获得成效。

### 从angularJS中获取的经验与区别

	1. MVC的微架构模式
	2. 在angularjs应用程序中，试图都应该是由指令组成，各种指令互相协作，从而完成功能完整的用户界面
	3. 服务负责封装应用的业务逻辑。在服务代码中，可以通过HTTP与RESTful服务进行通信。
	4. 控制器主要负责处理用户输入并把执行过程代理给对应的服务
	5. 构建angularjs的最佳实践是：
		控制器不应该操作DOM，而是应该把访问和操作DOM的逻辑分离到指令中去。如果控制器之间有一些重复的逻辑，最大的可能就是：我们需要把这些逻辑封装到某个服务里面，如果某个控制器需要用到这些功能，就使用angular JS的依赖注入机制注入这个服务。
	6. scope
		angularJS中的数据绑定机制是利用scope对象来实现的，首先在scope对象上添加各种属性，然后在模版中显式声明需要绑定这些属性（单向绑定或者双向绑定）。还有重要职责：派发事件和实现基于脏值检测的行为
	   `controller as syntax`
		允许直接在控制器内部为当前上下文（this）添加属性，而不需要显式注入scope对象，然后再在上面添加书序。
		
		```
		<div ng-controller="MainCtrl as main">
			  <button ng-click="main.clicked()">Click</button>
			</div>
			function MainCtrl() {
			  this.name = 'Foobar';
		}
		MainCtrl.prototype.clicked = function () {
		  alert('You clicked me!');
		};
		```
		angular2删除了scope对象，所有表达式都在特定UI组件的上下文中执行。把scope API整体删除掉之后使得Angular2得到了大幅度简化，不再需要显式注入scope了，只要把属性直接添加到UI组件上，然后再进行绑定操作即可。

	7. 依赖注入
		DI带来的好处：易测试，更好的代码结构和模块化，以及更简洁明了。
		angularJS采用了依赖注入
		angular2使用ES2016的装饰器（decorator）语法对使用DI的代码进行了注解。

	8. 服务端渲染

		可以把单页应用中所请求的某个视图再服务端渲染好，然后把对应的HTML直接发送给用户。随后，在所有资源处理完毕之后，脚本就会添加事件监听器并进行数据绑定操作。
		好处：提升用户体验，构建SEO友好的应用
		angularjs不支持

	9. 大规模应用
		angularJS中不同的监视器之间有相互依赖，从而导致了digest循环必须进行若干次遍历，才能使得表达的结果才能最终趋于稳定。
		angular2采用单向数据流，具备如下的优点：
		* 更明确的数据流
		* 不同的数据绑定之间没有依赖关系，所以digest没有存活时间的概念
		* 性能更高，（digest循环只运行一次，创建对immutable/abservable（不可变/可观察）数据模型友好的应用程序，从而可以做深度优化。

	10. 模版
		模版是简单的HTML，并且不需要中间的处理和编译过程。
		模版式angularjs的核心特性之一。

	11. 脏值检测
		内联缓存（利用JavaScript虚拟机的代码优化机制可以获得显著的性能提升，其中一种优化叫内联缓存）
		angular2中有2种内置脏值检测机制：
		* 动态脏值检测，与angularjs中的脏值检测机制类似，用于不允许eval()的系统中，如csp插件和chrome插件
		* JIT脏值检测，运行时动态生成脏值检测代码，运行JavaScript虚拟机进行深度代码优化


## 02 Angular2应用的基础构件

	本章主要介绍angular2核心组件的概要介绍，后面作深入介绍

	1. Component（组件）
	component是angular2中创建用户界面的主要构件。
	component直接继承自Directives，扩展了更多特性，如增加视图的概念，可以在视图上绑定模版，从而可以渲染各种指令的组合体

	指令的用途是封装与DOM相关的逻辑，通过扩展HTML的语法和语义来构建组件，然后把这些组件组合到一起构建出用户界面。

	2. Pipe（管道）是angular2中的另一个组件，类似于angularjs中的过滤器

	3. 脏值检测
	Differ（差异比较器）来优化脏值检测机制。

	digest循环：
		Angular在指令ng-model和ng-bind（在我们这个例子里面也就是取值指令{{}}）内部为同一个表达式label添加了多个watcher（监视器），以实现不同的行为。这些监视器与经典的MVC模式中的观察者非常类似。在指定的事件发生的时候（在我们的例子中，也就是文本输入框中的内容发生改变的时候），AngularJS将循环遍历所有监视器，在指定的scope上下文中运算与之相关的表达式并把结果存储起来。这种循环就是所谓的digest循环。

	4. 分区
	5. 服务
	6. 路由

## 03 TypeScript速成

	1. 元数据
	2. 装饰器
	3. 模块（导入，导出，default）
	4. 静态类型
	5. 类型参数
	6. 静态类型参数-范型

## 04 组件和指令入门

### 指令

	1. 对于同一个HTML标签，只能定义一个组件，但是可以使用多个指令。
	2. 指令只是把标签参数化，而组件是视图里面真实的HTML元素
	3. angular核心团队推荐把指令当成标签属性使用，并且加上命名空间作为前缀

ElementRef，这个类可以用来在宿主标签里面注入其它标签的阴影
hostListener(evevtname)，方法装饰器，参数是事件名

### 组件

	@output，所有组件的输出内容都必须是EvenEmitter类的实例

### 脏值检测

	angular2的脏值检测机制运行的上下文是独立的组件

	分区会拦截浏览器发出的所有异步请求，并为框架的脏值检测机制提供执行上下文

	脏值检测方式：
	1. DynamicChangeDetector
	2. JitChangeDetector，实现利用了js虚拟机的内联缓存机制

	脏值检测策略：
	1. CheckOnce，只有在组件初始化的时候运行一次
	2. Checked，
	3. CheckAlways，这个策略会让检测器一直运行
	4. Detached，这个脏值检测器子树将会被认为不是主树上的一部分，并在检测的时候会被跳过
	5. Default
	6. OnPush


## 05 依赖注入

## 06 路由和表单

### 表单

1. 模版驱动型，提供了一种声明式API，可以把校验规则声明到组件的模版中

2. 数据模型驱动型，用FormBuilder提供必要的API

## 07 管道与RESTful服务之间的通信

管道分为：

1. 有状态管道

2. 无状态管道

## 08 服务端渲染





















	
