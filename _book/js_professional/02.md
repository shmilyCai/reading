# 面向对象的程序设计与函数表达式

## 创建对象

	1. 工厂模式
	使用简单的函数创建对象，为对象添加属性和方法，然后返回对象

	2. 构造函数
	可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。
	缺点：级它的每个成员都无法得到复用，包括函数，即不存在共享函数。

	3. 原型模式
	使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法

## 继承

	1. 原型链继承
	js通过原型链实现继承。
	原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。
	这样，子类型就能够访问超类型的所有属性和方法。
	原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。
	借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性

	2. 原型式继承
	可以在不必须预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造

	3. 寄生式继承
	与原型式继承相似，也是基于某个对象或者某些信息创建一个对象，然后增强对象，最后返回对象。
	为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用

	4. 寄生组合式继承
	集寄生式继承和组合继承的有点与一身，是实现基于类型继承的最有效方式



## 函数声明

重要特征：在执行代码之前会先读取函数声明，意味着可以把函数声明放在调用它的语句后面

```
//函数声明
function name(){}
```

## 函数声明与函数表达式

看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量functionName，创建的函数称为匿名函数。

函数表达式在使用前必须先赋值。

```

//函数表达式
var name = function(){}

```

特点：

	1. 函数表达式不同于函数声明，函数声明要求有名字，但是函数表达式不需要，没有名字的函数表达式也叫做匿名函数
	2. 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂
	3. 递归函数应该始终使用argument.callee来递归的调用自身，不要使用函数名，函数名可能会发生变化

## 闭包

当在函数内部定义了其它函数时，就创建了闭包。

闭包有权访问包含函数内部的所有变量

原理：

	1. 在后台执行环境中，闭包的作用域链包含着它自己的作用域，包含函数的作用域和全局作用域
	2. 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁
	3. 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止

使用闭包可以在js中模仿块级作用域，要点：

	1. 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用
	2. 结果就是函数内部的所有变量都会被立即销毁，除非某些变量赋值给了包含作用域（即外部作用域）中的变量

使用闭包可用于在对象中创建私有变量，要点：

	1. js中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量
	2. 有权访问私有变量的公有方法叫特权方法
	3. 可以使用构造函数模式，原型模式来实现自定义类型的特权方法，也可以使用模块模式，增强的模块模式来实现单例的特权方法
































